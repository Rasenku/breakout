/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (() => {

eval("// JavaScript code goes here\n  \nconst canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d');\n\nconst ballRadius = 10;\nconst paddleHeight = 10;\nconst paddleWidth = 75;\nconst brickRowCount = 5;\nconst brickColumnCount = 3;\nconst brickWidth = 75;\nconst brickHeight = 20;\nconst brickPadding = 10;\nconst brickOffsetTop = 30;\nconst brickOffsetLeft = 30;\nlet paddleXStart = (canvas.width - paddleWidth) / 2;\nconst paddleYStart = canvas.height - paddleHeight;\nconst PI2 = Math.PI * 2;\nconst objcolor = '#0095DD';\n\n\nclass Sprite {\n  constructor(x = 0, y = 0, width = 100, height = 100, color = \"red\"){\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.color = color;\n  }\n  render(ctx){\n    ctx.beginPath()\n    ctx.rect(this.x, this.y, this.width, this.height)\n    ctx.fillStyle = this.color\n    ctx.fill()\n    ctx.closePath()\n  }\n\n  render(ctx) {\n    ctx.beginPath();\n    ctx.rect(this.x, this.y, this.width, this.height);\n    ctx.fillStyle = this.color;\n    ctx.fill();\n    ctx.closePath();\n  }\n\n  reset(paddleXStart) {\n    this.x = paddleXStart;\n  }\n\n  moveBy(dx, dy) {\n    this.x += dx;\n    this.y += dy;\n  }\n\n  moveTo(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass Ball extends Sprite {\n  constructor(x = 0, y = 0, dx = 2, dy = -1, radius = 10) {\n    super(x, y, radius*2, radius*2, \"#0095DD\")\n    this.dx = dx;\n    this.dy = -dy;\n    this.radius = radius;\n    this.PI2 = Math.PI * 2;\n  }\n  // moves our ball, using sprite moveBy\n  move() {\n    this.moveBy(this.dx, this.dy);\n  }\n\n  render(ctx){\n    ctx.beginPath()\n    ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2)\n    ctx.fillStyle = this.color\n    ctx.fill()\n    ctx.closePath()\n  }\n\n  reset(canvas) {\n    this.x = canvas.width / 2;\n    this.y = canvas.height - 30;\n    this.dx = 3;\n    this.dy = -3;\n  }\n}\n\nclass Brick extends Sprite{\n  constructor(x,y, width = 75, height = 20, color = \"#0095DD\"){\n    super(x, y, width, height, color)\n    this.status = 1;\n  }\n}\n\n// creates our Bricks class \nclass Bricks {\n  constructor(cols, rows, width, height, padding, OffsetTop, OffsetLeft, color) {\n    this.cols = cols;\n    this.rows = rows;\n    this.bricks = [];\n    this.width = width;\n    this.height = height;\n    this.padding = padding;\n    this.OffsetLeft = OffsetLeft;\n    this.OffsetTop = OffsetTop;\n    this.color = color;\n\n    this.init();\n  }\n\n  // orients our new bricks in their positions\n  init() {\n    for (let c = 0; c < this.cols; c += 1) {\n      this.bricks[c] = [];\n      for (let r = 0; r < this.rows; r += 1) {\n        const brickX = (c * (this.width + this.padding)) + this.OffsetLeft;\n        const brickY = (r * (this.height + this.padding)) + this.OffsetTop;\n        if (c % 2 === 0) {\n          this.bricks[c][r] = new Brick(brickX, brickY, this.width + (c * 2.5),\n            this.height + (r * 2.5), this.color);\n        } else if (r % 2 === 0) {\n          this.bricks[c][r] = new Brick(brickX, brickY, this.width, this.height, \"pink\");\n        } else {\n          this.bricks[c][r] = new Brick(brickX, brickY, this.width, this.height, \"yellow\");\n        }\n      }\n    }\n  }\n\n  // draws our bricks\n  render(ctx) {\n    for (let c = 0; c < this.cols; c += 1) {\n      for (let r = 0; r < this.rows; r += 1) {\n        const brick = this.bricks[c][r];\n        if (brick.status === 1) {\n          brick.render(ctx);\n        }\n      }\n    }\n  }\n}\n\nclass Lables extends Sprite {\n  // Lable's params\n  constructor(x, y, color, txt, font = \"16px Arial\") {\n    // Sprite's params\n    super(x, y, 0, 0, color);\n    this.txt = txt;\n    this.font = font;\n    this.value = 0;\n  }\n\n  // overrides Sprites render method\n  render(ctx) {\n    ctx.font = this.font;\n    ctx.fillStyle = this.color;\n    ctx.fillText(`${this.txt} ${this.value}`, this.x, this.y);\n  }\n}\n\n// creates our main opperations class\nclass Game {\n  constructor() {\n    // Ball class\n    this.ball = new Ball(0, 0, 2, -2, ballRadius, '#0095DD');\n\n    // Paddle Class\n    this.paddle = new Sprite(paddleXStart, paddleYStart,\n      paddleWidth, paddleHeight, '#0095DD');\n\n    // Bricks Class\n    this.brick = new Brick(brickColumnCount, brickRowCount,\n      brickWidth, brickHeight, '#0095DD');\n    this.bricks = new Bricks(brickColumnCount, brickRowCount,\n      brickWidth, brickHeight, brickPadding,\n      brickOffsetLeft, brickOffsetTop, '#0095DD');\n\n    // Lables Class\n    this.score = new Lables(8, 20, '#0095DD', \"Score: \");\n    this.lives = new Lables(canvas.width - 65, 20, '#0095DD', \"Lives: \");\n\n    // Setup\n    this.leftPressed = false;\n    this.rightPressed = false;\n    this.setup();\n  }\n\n  setup() {\n    this.lives.value = 3;\n    this.resetBallAndPaddle();\n    document.addEventListener(\"keydown\", ((e) => {\n      this.keyDownHandler(e);\n    }), false);\n    document.addEventListener(\"keyup\", ((e) => {\n      this.keyUpHandler(e);\n    }), false);\n    document.addEventListener(\"mousemove\", ((e) => {\n      this.mouseMoveHandler(e);\n    }), false);\n  }\n\n  // resets our ball and Paddle\n  resetBallAndPaddle() {\n    this.ball.reset(canvas);\n    this.paddle.reset(paddleXStart);\n  }\n\n  // creates win conditions and tests collisions with bricks\n  collisionDetection() {\n    for (let c = 0; c < this.bricks.cols; c += 1) {\n      for (let r = 0; r < this.bricks.rows; r += 1) {\n        const brick = this.bricks.bricks[c][r];\n        if (brick.status === 1) {\n          if (this.ball.x > brick.x\n            && this.ball.x < brick.x + brick.width\n            && this.ball.y > brick.y\n            && this.ball.y < brick.y + brick.height) {\n            this.ball.dy = -this.ball.dy;\n            brick.status = 0;\n            this.score.value += 1;\n            if (this.score.value === this.bricks.cols * this.bricks.rows) {\n              alert(\"YOU WIN, CONGRATS!\");\n              document.location.reload();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // controls the movement of our paddle\n  movePaddle() {\n    if (this.rightPressed && this.x < canvas.width - this.width) {\n      this.paddle.moveBy(7, 0);\n    } else if (this.leftPressed && this.x > 0) {\n      this.paddle.moveBy(-7, 0);\n    }\n  }\n\n  // creates lose conditions and tests collisions with canvas/paddle\n  collisionWithCanvasAndPaddle() {\n    if (this.ball.x + this.ball.dx > canvas.width - this.ball.radius\n      || this.ball.x + this.ball.dx < this.ball.radius) {\n      this.ball.dx = -this.ball.dx;\n    }\n    if (this.ball.y + this.ball.dy < this.ball.radius) {\n      this.ball.dy = -this.ball.dy;\n    } else if (this.ball.y + this.ball.dy > canvas.height - this.ball.radius) {\n      if (this.ball.x > this.paddle.x && this.ball.x < this.paddle.x + this.paddle.width) {\n        this.ball.dy = -this.ball.dy;\n      } else {\n        this.lives.value -= 1;\n        if (this.lives.value < 1) {\n          alert(\"GAME OVER\");\n          this.lives = 3;\n          document.location.reload();\n        } else {\n          this.resetBallAndPaddle();\n        }\n      }\n    }\n  }\n\n  // tests if the keys are held down/pressed\n  keyDownHandler(e) {\n    if (e.key === 39) {\n      this.rightPressed = true;\n    } else if (e.key === 37) {\n      this.leftPressed = true;\n    }\n  }\n\n  // tests if the keys are up/not pressed\n  keyUpHandler(e) {\n    if (e.key === 39) {\n      this.rightPressed = false;\n    } else if (e.key === 37) {\n      this.leftPressed = false;\n    }\n  }\n\n  // controls our paddle using the mouse\n  mouseMoveHandler(e) {\n    const relativeX = e.clientX - canvas.offsetLeft;\n    if (relativeX > 0 && relativeX < canvas.width) {\n      this.paddle.moveTo(relativeX - this.paddle.width / 2, paddleYStart);\n    }\n  }\n\n  // displays our game and runs necessary functions\n  draw() {\n    // creates our canvas and colors it's background\n    ctx.rect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = \"purple\";\n    ctx.fill();\n    // creates our assests\n    this.bricks.render(ctx);\n    this.ball.render(ctx);\n    this.paddle.render(ctx);\n    this.score.render(ctx);\n    this.lives.render(ctx);\n    // runs our functions for gameplay\n    this.collisionDetection();\n    this.ball.move();\n    this.movePaddle();\n    this.collisionWithCanvasAndPaddle();\n    // requestAnimationFrame(this.draw.bind(this));\n    requestAnimationFrame(() => {\n      this.draw();\n    });\n  }\n}\n\n// creates new game\nconst game = new Game();\n// runs our program! (or at least it used to)\ngame.draw();\n\n//# sourceURL=webpack://breakout/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.js"]();
/******/ 	
/******/ })()
;